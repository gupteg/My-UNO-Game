const http = require('http');
const express = require('express');
const path = require('path');
const { Server } = require("socket.io");

const app = express();
const server = http.createServer(app);
const io = new Server(server);

app.use(express.static(path.join(__dirname, 'public')));

app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// --- SERVER-SIDE GAME STATE ---
let players = []; // Lobby players { playerId, name, isHost }
let gameState = null;
let reconnectTimers = {};
const DISCONNECT_GRACE_PERIOD = 60000;

// --- GAME LOGIC FUNCTIONS ---

function addLog(message) {
    if (io) {
        io.emit('gameLog', message);
    }
}

function createDeck() {
    const deck = []; const colors = ['Red', 'Green', 'Blue', 'Yellow']; const values = ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'Skip', 'Reverse', 'Draw Two'];
    for (const color of colors) { deck.push({ color, value: '0' }); for (let i = 0; i < 2; i++) { for (const value of values) { deck.push({ color, value }); } } }
    for (let i = 0; i < 4; i++) { deck.push({ color: 'Black', value: 'Wild' }); deck.push({ color: 'Black', value: 'Wild Draw Four' }); deck.push({ color: 'Black', value: 'Wild Pick Until' }); } deck.push({ color: 'Black', value: 'Wild Swap' }); return deck;
}
function calculateScore(hand) {
    let score = 0; hand.forEach(card => { if (!isNaN(card.value)) { score += parseInt(card.value); } else { switch(card.value) { case 'Wild Swap': score += 100; break; case 'Draw Two': score += 25; break; case 'Skip': case 'Reverse': score += 20; break; default: score += 50; break; } } }); return score;
}
function shuffleDeck(deck) { for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; } return deck; }

function setupGame(lobbyPlayers) {
    const gamePlayers = lobbyPlayers.map(p => ({ playerId: p.playerId, socketId: p.socketId, name: p.name, isHost: p.isHost, score: 0, hand: [], unoState: 'safe', scoresByRound: [], status: 'Active' }));
    return { players: gamePlayers, dealerIndex: -1, numCardsToDeal: 7, discardPile: [], drawPile: [], gameWinner: null, winnerOnHold: [], roundNumber: 0, isPaused: false, pauseInfo: { pauseEndTime: null, pausedForPlayerNames: [] }, readyForNextRound: [], playDirection: 1 };
}

function startNewRound(gs) {
    gs.roundNumber++; const numPlayers = gs.players.length; let roundDeck = shuffleDeck(createDeck()); gs.players.forEach(player => { if (player.status === 'Active') { player.hand = roundDeck.splice(0, gs.numCardsToDeal); player.unoState = 'safe'; } else { player.hand = []; } }); let topCard = roundDeck.shift(); while (topCard.value === 'Wild Draw Four' || topCard.value === 'Wild Swap') { roundDeck.push(topCard); roundDeck = shuffleDeck(roundDeck); topCard = roundDeck.shift(); } gs.discardPile = [{ card: topCard, playerName: 'Deck' }]; gs.drawPile = roundDeck; gs.activeColor = topCard.color; gs.drawPenalty = 0; gs.needsColorChoice = null; gs.needsPickUntilChoice = null; gs.pickUntilState = null; gs.needsSwapChoice = null; gs.swapState = null; gs.roundOver = false; gs.needsDealChoice = null; gs.winnerOnHold = []; gs.isPaused = false; gs.pauseInfo = { pauseEndTime: null, pausedForPlayerNames: [] }; gs.readyForNextRound = []; const dealer = gs.players[gs.dealerIndex]; addLog(`Round ${gs.roundNumber} begins. ${dealer.name} deals ${gs.numCardsToDeal} cards.`); let firstPlayerIndex = (gs.dealerIndex + 1) % numPlayers; while (gs.players[firstPlayerIndex].status !== 'Active') { firstPlayerIndex = (firstPlayerIndex + 1) % numPlayers; }
    if (topCard.color !== 'Black') { const connectedPlayersCount = gs.players.filter(p => p.status === 'Active').length; if (topCard.value === 'Reverse') { if (connectedPlayersCount > 2) { gs.playDirection *= -1; addLog(`Direction reversed! Play is now ${gs.playDirection === 1 ? 'clockwise' : 'counter-clockwise'}.`); let tempIndex = gs.dealerIndex; do { tempIndex = (tempIndex + gs.playDirection + numPlayers) % numPlayers; } while (gs.players[tempIndex].status !== 'Active'); firstPlayerIndex = tempIndex; } else { let tempIndex = firstPlayerIndex; do { tempIndex = (tempIndex + gs.playDirection + numPlayers) % numPlayers; } while (gs.players[tempIndex].status !== 'Active'); firstPlayerIndex = tempIndex; } } else if (topCard.value === 'Skip') { let tempIndex = firstPlayerIndex; do { tempIndex = (tempIndex + gs.playDirection + numPlayers) % numPlayers; } while (gs.players[tempIndex].status !== 'Active'); firstPlayerIndex = tempIndex; } if (topCard.value === 'Draw Two') { applyCardEffect(topCard); } } else { gs.needsColorChoice = dealer.playerId; gs.discardPile[0].playerName = dealer.name; if (topCard.value === 'Wild Pick Until') { gs.needsPickUntilChoice = dealer.playerId; } } gs.currentPlayerIndex = firstPlayerIndex; return gs;
}

function isMoveValid(playedCard, topCard, activeColor, drawPenalty) { if (!topCard) return true; if (drawPenalty > 0) return playedCard.value === topCard.value; if (playedCard.color === 'Black') return true; if (playedCard.color === activeColor || playedCard.value === topCard.value) return true; return false; }
function advanceTurn() { if (!gameState || gameState.roundOver) return; const activePlayers = gameState.players.filter(p => p.status === 'Active'); if (activePlayers.length === 0) { addLog("No active players left."); return; } const currentPlayer = gameState.players[gameState.currentPlayerIndex]; if (currentPlayer && currentPlayer.unoState === 'declared') { currentPlayer.unoState = 'safe'; } do { const numPlayers = gameState.players.length; gameState.currentPlayerIndex = (gameState.currentPlayerIndex + gameState.playDirection + numPlayers) % numPlayers; } while (gameState.players[gameState.currentPlayerIndex].status !== 'Active'); }

function applyCardEffect(playedCard) {
    switch(playedCard.value) {
        case 'Reverse':
            if (gameState.players.filter(p=>p.status === 'Active').length > 2) {
                gameState.playDirection *= -1;
                addLog(`Direction reversed! Play is now ${gameState.playDirection === 1 ? 'clockwise' : 'counter-clockwise'}.`); // Log added
            }
            break;
        case 'Draw Two':
        case 'Wild Draw Four':
            const penalty = (playedCard.value === 'Draw Two') ? 2 : 4;
            gameState.drawPenalty += penalty;
            break;
    }
}

function handleEndOfRound(winners) { if (!gameState || gameState.roundOver) return; gameState.roundOver = true; gameState.readyForNextRound = []; const scoresForRound = []; gameState.players.forEach(p => { const roundScore = (p.status === 'Active' || p.status === 'Disconnected') ? calculateScore(p.hand) : 0; p.score += roundScore; p.scoresByRound.push((p.status === 'Active' || p.status === 'Disconnected') ? roundScore : '-'); scoresForRound.push({ name: p.name, roundScore: roundScore, cumulativeScore: p.score }); }); const winnerNames = winners.map(w => w.name).join(' and '); addLog(`ðŸ ${winnerNames} wins the round!`); io.emit('announceRoundWinner', { winnerNames }); io.emit('roundOver', { winnerName: winnerNames, scores: scoresForRound, finalGameState: gameState }); }
function handleCardPlay(playerIndex, cardIndex) { if (!gameState || playerIndex !== gameState.currentPlayerIndex || gameState.roundOver || gameState.isPaused) return; const player = gameState.players[playerIndex]; if (!player || !player.hand[cardIndex]) return; const playedCard = player.hand[cardIndex]; const topDiscard = gameState.discardPile[0]; const topCard = topDiscard ? topDiscard.card : null; const actionCardsThatDelayWin = ['Draw Two', 'Wild Draw Four', 'Wild Pick Until']; if (isMoveValid(playedCard, topCard, gameState.activeColor, gameState.drawPenalty)) { io.emit('animatePlay', { playerId: player.playerId, card: playedCard, cardIndex: cardIndex }); player.hand.splice(cardIndex, 1); const cardName = `${playedCard.color !== 'Black' ? playedCard.color + ' ' : ''}${playedCard.value}`; addLog(`â€º ${player.name} played a ${cardName}.`); if (player.hand.length === 1 && player.unoState !== 'declared') { if (gameState.drawPile.length > 0) player.hand.push(gameState.drawPile.shift()); if (gameState.drawPile.length > 0) player.hand.push(gameState.drawPile.shift()); player.unoState = 'safe'; io.to(player.socketId).emit('announce', 'Penalty! You forgot to call UNO.'); addLog(` penalty on ${player.name} for not calling UNO.`); io.emit('animateDraw', { playerId: player.playerId, count: 2 }); } else if (player.hand.length === 1 && player.unoState === 'declared') { io.emit('unoCalled', { playerName: player.name }); } else if (player.hand.length > 1) { player.unoState = 'safe'; } if (player.hand.length === 0) { if (actionCardsThatDelayWin.includes(playedCard.value)) { gameState.winnerOnHold.push(player.playerId); } else { handleEndOfRound([player]); return; } } if (player.hand.length === 1 && player.unoState === 'declared') { player.unoState = 'safe'; } gameState.discardPile.unshift({ card: playedCard, playerName: player.name }); if (playedCard.value === 'Wild Pick Until') { gameState.needsPickUntilChoice = player.playerId; return; } else if (playedCard.value === 'Wild Swap') { gameState.swapState = { choosingPlayerId: player.playerId }; gameState.needsColorChoice = player.playerId; return; } applyCardEffect(playedCard); let skipTurn = false; if (playedCard.value === 'Skip' || (playedCard.value === 'Reverse' && gameState.players.filter(p=>p.status === 'Active').length === 2)) { skipTurn = true; } if (playedCard.color === 'Black') { gameState.needsColorChoice = player.playerId; if (skipTurn) { gameState.skipNextTurnAfterColor = true; } } else { gameState.activeColor = playedCard.color; if (skipTurn) { advanceTurn(); } advanceTurn(); } } else { io.to(player.socketId).emit('announce', 'Invalid move!'); } }
function handlePlayerRemoval(playerId) { if (!gameState) return; const player = gameState.players.find(p => p.playerId === playerId); if (player && player.status === 'Disconnected') { player.status = 'Removed'; addLog(`Player ${player.name} removed.`); if (reconnectTimers[playerId]) { clearTimeout(reconnectTimers[playerId]); delete reconnectTimers[playerId]; } if (player.isHost) { const nextActivePlayer = gameState.players.find(p => p.status === 'Active'); if (nextActivePlayer) { nextActivePlayer.isHost = true; addLog(`${nextActivePlayer.name} is new host.`); } else { addLog(`No active players left.`); } } const activePlayers = gameState.players.filter(p => p.status === 'Active'); if (activePlayers.length < 2) { addLog('Game over.'); io.emit('finalGameOver', gameState); gameState = null; reconnectTimers = {}; return; } const remainingDisconnected = gameState.players.filter(p => p.status === 'Disconnected'); if (remainingDisconnected.length === 0 && gameState.isPaused) { gameState.isPaused = false; gameState.pauseInfo = { pauseEndTime: null, pausedForPlayerNames: [] }; addLog("Game resumed."); } else if (gameState.isPaused) { gameState.pauseInfo.pausedForPlayerNames = remainingDisconnected.map(p => p.name); } if (!gameState.roundOver && gameState.players[gameState.currentPlayerIndex]?.playerId === playerId) { addLog(`Advancing turn.`); advanceTurn(); } io.emit('updateGameState', gameState); } else if (reconnectTimers[playerId]) { clearTimeout(reconnectTimers[playerId]); delete reconnectTimers[playerId]; } }

// --- SOCKET.IO LOGIC ---
io.on('connection', (socket) => {
  console.log(`Connected: ${socket.id}`);
  socket.on('joinGame', ({ playerName, playerId }) => { if (gameState) { let playerToRejoin = null; if (playerId) { playerToRejoin = gameState.players.find(p => p.playerId === playerId && p.status !== 'Active'); } if (!playerToRejoin) { /* ... hybrid logic ... */ } if (playerToRejoin) { playerToRejoin.status = 'Active'; playerToRejoin.socketId = socket.id; playerToRejoin.name = playerName; if (reconnectTimers[playerToRejoin.playerId]) { clearTimeout(reconnectTimers[playerToRejoin.playerId]); delete reconnectTimers[playerToRejoin.playerId]; } addLog(`Player ${playerToRejoin.name} reconnected!`); const otherDisconnected = gameState.players.filter(p => p.status === 'Disconnected'); if (otherDisconnected.length === 0 && gameState.isPaused) { gameState.isPaused = false; gameState.pauseInfo = { pauseEndTime: null, pausedForPlayerNames: [] }; addLog("Game resumed."); } else if (gameState.isPaused) { gameState.pauseInfo.pausedForPlayerNames = otherDisconnected.map(p => p.name); } socket.emit('joinSuccess', { playerId: playerToRejoin.playerId, lobby: gameState.players }); io.emit('updateGameState', gameState); return; } else { socket.emit('announce', 'Game in progress.'); return; } } let pId = playerId || Math.random().toString(36).substr(2, 9); const existingPlayer = players.find(p => p.playerId === pId); if (existingPlayer) { existingPlayer.socketId = socket.id; existingPlayer.name = playerName; } else { const isHost = players.length === 0; players.push({ playerId: pId, socketId: socket.id, name: playerName, isHost }); } socket.emit('joinSuccess', { playerId: pId, lobby: players }); socket.broadcast.emit('lobbyUpdate', players); });
  socket.on('rejoinGame', (playerId) => { if (!gameState || !playerId) return; const playerToRejoin = gameState.players.find(p => p.playerId === playerId); if (playerToRejoin && playerToRejoin.status !== 'Active') { playerToRejoin.status = 'Active'; playerToRejoin.socketId = socket.id; if (reconnectTimers[playerToRejoin.playerId]) { clearTimeout(reconnectTimers[playerToRejoin.playerId]); delete reconnectTimers[playerToRejoin.playerId]; } addLog(`Player ${playerToRejoin.name} reconnected!`); const otherDisconnected = gameState.players.filter(p => p.status === 'Disconnected'); if (otherDisconnected.length === 0 && gameState.isPaused) { gameState.isPaused = false; gameState.pauseInfo = { pauseEndTime: null, pausedForPlayerNames: [] }; addLog("Game resumed."); } else if (gameState.isPaused) { gameState.pauseInfo.pausedForPlayerNames = otherDisconnected.map(p => p.name); } io.emit('updateGameState', gameState); } else if (playerToRejoin && playerToRejoin.status === 'Active') { playerToRejoin.socketId = socket.id; socket.emit('updateGameState', gameState); } });
  socket.on('kickPlayer', ({ playerIdToKick }) => { if (gameState) return; const host = players.find(p => p.socketId === socket.id && p.isHost); if (host) { const playerToKick = players.find(p => p.playerId === playerIdToKick); if (playerToKick) { players = players.filter(player => player.playerId !== playerIdToKick); io.emit('lobbyUpdate', players); const kickedSocket = io.sockets.sockets.get(playerToKick.socketId); if (kickedSocket) { kickedSocket.emit('announce', 'Kicked by host.'); setTimeout(() => kickedSocket.disconnect(true), 1000); } } } });
  socket.on('startGame', () => { const host = players.find(p => p.socketId === socket.id && p.isHost); if (host && players.length >= 2 && !gameState) { gameState = setupGame(players); const hostIndex = gameState.players.findIndex(p => p.isHost); gameState.dealerIndex = hostIndex !== -1 ? hostIndex : 0; gameState.needsDealChoice = gameState.players[gameState.dealerIndex].playerId; io.emit('updateGameState', gameState); players = []; } });
  function checkAndStartNextRound() { if (!gameState || !gameState.roundOver) return; const host = gameState.players.find(p => p.isHost && p.status !== 'Removed'); const activePlayers = gameState.players.filter(p => p.status === 'Active'); if (!host) return; const hostIsReady = gameState.readyForNextRound.includes(host.playerId); const allActivePlayersReady = activePlayers.every(p => gameState.readyForNextRound.includes(p.playerId)); if (hostIsReady && allActivePlayersReady) { let nextDealerIndex = gameState.dealerIndex; do { nextDealerIndex = (nextDealerIndex + 1) % gameState.players.length; } while (gameState.players[nextDealerIndex].status === 'Removed'); gameState.dealerIndex = nextDealerIndex; const dealer = gameState.players[nextDealerIndex]; if (dealer.status === 'Disconnected') { addLog(`${dealer.name} is dealer but disconnected. Dealing default.`); gameState.numCardsToDeal = 7; gameState = startNewRound(gameState); io.emit('updateGameState', gameState); } else { gameState.needsDealChoice = dealer.playerId; gameState.roundOver = false; io.emit('updateGameState', gameState); } } }
  socket.on('playerReadyForNextRound', () => { if (!gameState || !gameState.roundOver) return; const player = gameState.players.find(p => p.socketId === socket.id && p.status === 'Active'); if (player && !gameState.readyForNextRound.includes(player.playerId)) { gameState.readyForNextRound.push(player.playerId); addLog(`${player.name} is ready.`); checkAndStartNextRound(); io.emit('updateGameState', gameState); } });
  socket.on('dealChoice', ({ numCards }) => { if (!gameState || gameState.isPaused) return; const dealingPlayer = gameState.players.find(p => p.socketId === socket.id); if (gameState && gameState.needsDealChoice === dealingPlayer?.playerId) { const numToDeal = Math.max(1, Math.min(13, parseInt(numCards) || 7)); gameState.numCardsToDeal = numToDeal; gameState = startNewRound(gameState); io.emit('updateGameState', gameState); } });
  socket.on('endGame', () => { if(gameState) { const player = gameState.players.find(p => p.socketId === socket.id); if (player && player.isHost) { io.emit('finalGameOver', gameState); addLog(`Game ended by host ${player.name}.`); gameState = null; players = []; reconnectTimers = {}; } } });
  socket.on('playCard', ({ cardIndex }) => { if (!gameState || gameState.isPaused) return; const playerIndex = gameState.players.findIndex(p => p.socketId === socket.id); if (playerIndex !== -1) { handleCardPlay(playerIndex, cardIndex); if (gameState && !gameState.roundOver) { io.emit('updateGameState', gameState); } } });
  socket.on('callUno', () => { if (!gameState || gameState.isPaused) return; const player = gameState.players.find(p => p.socketId === socket.id); if (player && player.hand.length === 2 && gameState.players[gameState.currentPlayerIndex]?.playerId === player.playerId) { player.unoState = 'declared'; addLog(`ðŸ“£ ${player.name} is ready for UNO!`); } else if (player && player.hand.length !== 2) { io.to(socket.id).emit('announce', 'Can only call UNO with 2 cards.'); } });
  socket.on('drawCard', () => { if (!gameState || gameState.roundOver || gameState.isPaused) return; const playerIndex = gameState.players.findIndex(p => p.socketId === socket.id); if (playerIndex === gameState.currentPlayerIndex) { const player = gameState.players[playerIndex]; const topDiscard = gameState.discardPile[0]; const topCard = topDiscard ? topDiscard.card : null; if (gameState.drawPenalty === 0) player.unoState = 'safe'; if (gameState.pickUntilState?.active && gameState.pickUntilState.targetPlayerIndex === playerIndex) { if (gameState.drawPile.length > 0) { const drawnCard = gameState.drawPile.shift(); player.hand.push(drawnCard); io.emit('animateDraw', { playerId: player.playerId, count: 1 }); addLog(`â€º ${player.name} picking for ${gameState.pickUntilState.targetColor}...`); if (drawnCard.color === gameState.pickUntilState.targetColor) { player.hand.splice(player.hand.findIndex(c => c === drawnCard), 1); gameState.discardPile.unshift({ card: drawnCard, playerName: player.name }); gameState.activeColor = drawnCard.color; io.to(socket.id).emit('announce', `Drew target ${drawnCard.value} ${drawnCard.color}, played.`); addLog(`â€º ${player.name} found & played ${drawnCard.color}.`); applyCardEffect(drawnCard); if (player.hand.length === 0) { const hW = gameState.players.filter(p => gameState.winnerOnHold.includes(p.playerId)); handleEndOfRound([player, ...hW]); return; } if (gameState.winnerOnHold.length > 0) { const hW = gameState.players.filter(p => gameState.winnerOnHold.includes(p.playerId)); handleEndOfRound(hW); return; } gameState.pickUntilState = null; if (drawnCard.value === 'Skip' || (drawnCard.value === 'Reverse' && gameState.players.filter(p=>p.status === 'Active').length === 2)) advanceTurn(); advanceTurn(); } } else { addLog(`Draw pile empty! Cannot pick.`); gameState.pickUntilState = null; advanceTurn(); } } else if (gameState.drawPenalty > 0) { const penalty = gameState.drawPenalty; let drawnCount = 0; for (let i = 0; i < penalty; i++) { if (gameState.drawPile.length > 0) { player.hand.push(gameState.drawPile.shift()); drawnCount++; } else break; } if(drawnCount > 0) io.emit('animateDraw', { playerId: player.playerId, count: drawnCount }); addLog(`â€º ${player.name} drew ${drawnCount} card(s).`); gameState.drawPenalty = 0; if (gameState.winnerOnHold.length > 0) { const hW = gameState.players.filter(p => gameState.winnerOnHold.includes(p.playerId)); if (!hW.some(w => w.playerId === player.playerId)) { handleEndOfRound(hW); return; } else gameState.winnerOnHold = []; } advanceTurn(); } else { const hasPlayable = player.hand.some(card => card.color !== 'Black' && isMoveValid(card, topCard, gameState.activeColor, 0)); if (hasPlayable) { io.to(socket.id).emit('announce', 'Must play playable card.'); return; } if (gameState.drawPile.length > 0) { const drawnCard = gameState.drawPile.shift(); io.emit('animateDraw', { playerId: player.playerId, count: 1 }); addLog(`â€º ${player.name} drew.`); if (isMoveValid(drawnCard, topCard, gameState.activeColor, 0)) { if (drawnCard.color === 'Black') { player.hand.push(drawnCard); const cardIndex = player.hand.findIndex(c => c === drawnCard); io.to(socket.id).emit('drawnWildCard', { cardIndex, drawnCard }); return; } else { gameState.discardPile.unshift({ card: drawnCard, playerName: player.name }); gameState.activeColor = drawnCard.color; applyCardEffect(drawnCard); io.to(socket.id).emit('announce', `Drew playable ${drawnCard.value} ${drawnCard.color}, played.`); addLog(`...playable ${drawnCard.color} ${drawnCard.value}!`); if (drawnCard.value === 'Skip' || (drawnCard.value === 'Reverse' && gameState.players.filter(p=>p.status === 'Active').length === 2)) advanceTurn(); advanceTurn(); } } else { player.hand.push(drawnCard); advanceTurn(); } } else { addLog(`Draw pile empty! Pass.`); advanceTurn(); } } io.emit('updateGameState', gameState); } });
  socket.on('choosePlayDrawnWild', ({ play, cardIndex }) => { if (!gameState || gameState.isPaused) return; const playerIndex = gameState.players.findIndex(p => p.socketId === socket.id); const player = gameState.players[playerIndex]; if (!player || cardIndex < 0 || cardIndex >= player.hand.length) return; if (play) { handleCardPlay(playerIndex, cardIndex); } else { addLog(`â€º ${player.name} kept drawn Wild.`); advanceTurn(); } if (gameState && !gameState.roundOver) { io.emit('updateGameState', gameState); } });

  // *** MODIFIED: pickUntilChoice for discard wilds modal & history ***
  socket.on('pickUntilChoice', ({ choice }) => {
      if (!gameState || gameState.isPaused) return;
      const player = gameState.players.find(p => p.socketId === socket.id);
      if (!player || gameState.needsPickUntilChoice !== player.playerId) return;

      const numPlayers = gameState.players.length;
      const originalPlayerIndex = gameState.players.findIndex(p => p.socketId === socket.id);

      if (choice === 'discard-wilds') {
          addLog(`ðŸŒªï¸ ${player.name} forces others to discard Wilds!`);
          const winners = [];
          let discardedWildsInfo = []; // Store info for modal

          gameState.players.forEach(p => {
              if (p.socketId !== socket.id && p.status === 'Active') {
                  const originalHandSize = p.hand.length;
                  if (originalHandSize > 0) {
                      const wildsInHand = p.hand.filter(card => card.color === 'Black');
                      if (wildsInHand.length > 0) {
                          addLog(` ${p.name} discards ${wildsInHand.length} Wild(s).`);
                          discardedWildsInfo.push({ playerName: p.name, cards: [...wildsInHand] });
                          wildsInHand.forEach(wildCard => gameState.discardPile.unshift({ card: wildCard, playerName: p.name })); // Add to main pile
                          p.hand = p.hand.filter(card => card.color !== 'Black'); // Filter hand
                          if (p.hand.length === 0) winners.push(p);
                          else if (p.hand.length === 1 && originalHandSize > 1) p.unoState = 'unsafe';
                      }
                  }
              }
          });

          if (discardedWildsInfo.length > 0) {
                io.emit('showDiscardedWildsModal', discardedWildsInfo); // Emit for modal
          }

          if (winners.length > 0) { const hW = gameState.players.filter(p => gameState.winnerOnHold.includes(p.playerId)); handleEndOfRound([...winners, ...hW]); return; }
          if (gameState.winnerOnHold.length > 0) { const hW = gameState.players.filter(p => gameState.winnerOnHold.includes(p.playerId)); handleEndOfRound(hW); return; }
          gameState.needsColorChoice = player.playerId; // Still need color choice

      } else if (choice === 'pick-color') {
          let nextPlayerIndex = originalPlayerIndex; let searchLimit = numPlayers; let nextActivePlayerFound = false;
          do { nextPlayerIndex = (nextPlayerIndex + gameState.playDirection + numPlayers) % numPlayers; if (gameState.players[nextPlayerIndex].status === 'Active') { nextActivePlayerFound = true; break; } searchLimit--; } while (searchLimit > 0 && nextPlayerIndex !== originalPlayerIndex);
          if (nextActivePlayerFound && gameState.players[nextPlayerIndex].playerId !== player.playerId) { gameState.pickUntilState = { targetPlayerIndex: nextPlayerIndex, active: false, targetColor: null }; gameState.needsColorChoice = player.playerId; }
          else { addLog('No other active players. Choosing color.'); gameState.needsColorChoice = player.playerId; }
      }
      gameState.needsPickUntilChoice = null;
      io.emit('updateGameState', gameState);
  });

  socket.on('swapHandsChoice', ({ targetPlayerId }) => { if (!gameState || gameState.isPaused) return; const choosingPlayer = gameState.players.find(p => p.socketId === socket.id); if (!choosingPlayer || gameState.needsSwapChoice !== choosingPlayer.playerId) return; const targetPlayer = gameState.players.find(p => p.playerId === targetPlayerId && p.status === 'Active'); if (targetPlayer) { io.emit('animateSwap', { p1_id: choosingPlayer.playerId, p2_id: targetPlayer.playerId }); [choosingPlayer.hand, targetPlayer.hand] = [targetPlayer.hand, choosingPlayer.hand]; choosingPlayer.unoState = 'safe'; targetPlayer.unoState = 'safe'; addLog(`ðŸ¤ ${choosingPlayer.name} swapped with ${targetPlayer.name}!`); } else { addLog(`${choosingPlayer.name} invalid swap target.`); } gameState.needsSwapChoice = null; gameState.swapState = null; advanceTurn(); io.emit('updateGameState', gameState); });
  socket.on('colorChosen', ({ color }) => { if (!gameState || gameState.isPaused) return; const choosingPlayer = gameState.players.find(p => p.socketId === socket.id); if (!choosingPlayer || gameState.needsColorChoice !== choosingPlayer.playerId) return; addLog(`ðŸŽ¨ ${choosingPlayer.name} chose ${color}.`); gameState.activeColor = color; gameState.needsColorChoice = null; let advance = true; if (gameState.swapState) { gameState.needsSwapChoice = gameState.swapState.choosingPlayerId; advance = false; } else if (gameState.pickUntilState) { gameState.pickUntilState.active = true; gameState.pickUntilState.targetColor = color; gameState.currentPlayerIndex = gameState.pickUntilState.targetPlayerIndex; const targetPlayer = gameState.players[gameState.pickUntilState.targetPlayerIndex]; addLog(`â€º ${targetPlayer.name} must pick for ${color}!`); advance = false; } else { const isDealerChoosing = gameState.discardPile.length === 1 && gameState.discardPile[0].card.color === 'Black' && gameState.players[gameState.dealerIndex].playerId === choosingPlayer.playerId; if (isDealerChoosing) advance = false; if (gameState.skipNextTurnAfterColor) { advanceTurn(); gameState.skipNextTurnAfterColor = false; advance = true; } } if (advance) advanceTurn(); io.emit('updateGameState', gameState); });
  socket.on('rearrangeHand', ({ newHand }) => { if (!gameState) return; const player = gameState.players.find(p => p.socketId === socket.id); if (player) { if (newHand && Array.isArray(newHand) && newHand.length === player.hand.length) { player.hand = newHand; } else { console.warn(`Invalid rearrangeHand from ${player.name}.`); } } });
  socket.on('markPlayerAFK', ({ playerIdToMark }) => { if (!gameState || gameState.isPaused) return; const host = gameState.players.find(p => p.socketId === socket.id && p.isHost); const playerToMark = gameState.players.find(p => p.playerId === playerIdToMark); if (host && playerToMark && playerToMark.status === 'Active') { playerToMark.status = 'Disconnected'; addLog(`Host marked ${playerToMark.name} AFK. Paused.`); const wasPaused = gameState.isPaused; gameState.isPaused = true; const now = Date.now(); const endTime = wasPaused && gameState.pauseInfo.pauseEndTime ? gameState.pauseInfo.pauseEndTime : now + DISCONNECT_GRACE_PERIOD; const allDisconnected = gameState.players.filter(p => p.status === 'Disconnected'); gameState.pauseInfo = { pauseEndTime: endTime, pausedForPlayerNames: allDisconnected.map(p => p.name) }; if (!reconnectTimers[playerToMark.playerId]) { reconnectTimers[playerToMark.playerId] = setTimeout(() => { handlePlayerRemoval(playerToMark.playerId); }, DISCONNECT_GRACE_PERIOD); } io.to(playerToMark.socketId).emit('youWereMarkedAFK'); io.emit('updateGameState', gameState); } });
  socket.on('playerIsBack', () => { if (!gameState) return; const player = gameState.players.find(p => p.socketId === socket.id); if (player && player.status === 'Disconnected') { player.status = 'Active'; addLog(`Player ${player.name} is back!`); if (reconnectTimers[player.playerId]) { clearTimeout(reconnectTimers[player.playerId]); delete reconnectTimers[player.playerId]; } const otherDisconnected = gameState.players.filter(p => p.status === 'Disconnected'); if (otherDisconnected.length === 0 && gameState.isPaused) { gameState.isPaused = false; gameState.pauseInfo = { pauseEndTime: null, pausedForPlayerNames: [] }; addLog("Game resumed."); } else if (gameState.isPaused) { gameState.pauseInfo.pausedForPlayerNames = otherDisconnected.map(p => p.name); } io.emit('updateGameState', gameState); } });
  socket.on('disconnect', () => { console.log(`Disconnected: ${socket.id}`); if (gameState) { const disconnectedPlayer = gameState.players.find(p => p.socketId === socket.id); if (disconnectedPlayer && disconnectedPlayer.status === 'Active') { disconnectedPlayer.status = 'Disconnected'; addLog(`${disconnectedPlayer.name} disconnected. Paused.`); const wasPaused = gameState.isPaused; gameState.isPaused = true; const now = Date.now(); const endTime = wasPaused && gameState.pauseInfo.pauseEndTime ? gameState.pauseInfo.pauseEndTime : now + DISCONNECT_GRACE_PERIOD; const allDisconnected = gameState.players.filter(p => p.status === 'Disconnected'); gameState.pauseInfo = { pauseEndTime: endTime, pausedForPlayerNames: allDisconnected.map(p => p.name) }; if (!reconnectTimers[disconnectedPlayer.playerId]) { reconnectTimers[disconnectedPlayer.playerId] = setTimeout(() => { handlePlayerRemoval(disconnectedPlayer.playerId); }, DISCONNECT_GRACE_PERIOD); } io.emit('updateGameState', gameState); } } else { const pIndex = players.findIndex(p => p.socketId === socket.id); if (pIndex !== -1) { const wasHost = players[pIndex].isHost; players.splice(pIndex, 1); if (wasHost && players.length > 0 && !players.some(p => p.isHost)) { players[0].isHost = true; } io.emit('lobbyUpdate', players); } } });
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => { console.log(`âœ… UNO Server live on port ${PORT}`); });